"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const html_webpack_plugin_1 = __importDefault(require("html-webpack-plugin"));
class AsyncCssPlugin {
    constructor(options = {}) {
        Object.assign(this.options, options);
    }
    apply({ hooks }) {
        if (!hooks) {
            this.log("error", "hooks is undefined. Is the version of your webpack package too old?");
        }
        hooks.compilation.tap(AsyncCssPlugin.name, (compilation) => this.checkHook(compilation));
    }
    static assertUnreachable(value) {
        throw new Error(value);
    }
    options = { logLevel: "warn" };
    logged = false;
    log(messageType, message) {
        if (this.doLog(messageType)) {
            if (!this.logged) {
                this.logged = true;
                console.log(); // Make sure we start our log on a new line
            }
            console[messageType](`${AsyncCssPlugin.name}[${messageType}]: ${message}`);
        }
    }
    checkHook(compilation) {
        if (html_webpack_plugin_1.default?.getHooks) {
            const hooks = html_webpack_plugin_1.default.getHooks(compilation);
            hooks.alterAssetTags.tap(AsyncCssPlugin.name, (data) => this.checkTags(data, data.assetTags.styles));
        }
        else {
            this.log("error", "Cannot find hook. Is your configuration missing the HtmlWebpackPlugin?");
        }
    }
    doLog(messageType) {
        switch (this.options.logLevel) {
            case "info":
                return true;
            case "warn":
                return messageType !== "info";
            case "error":
                return messageType === "error";
            default:
                return AsyncCssPlugin.assertUnreachable(this.options.logLevel);
        }
    }
    checkTags(output, tags) {
        for (const { tagName, attributes } of tags) {
            if ((tagName === "link") && (attributes["rel"] === "stylesheet")) {
                this.processTag(output.outputName, attributes);
            }
        }
        return output;
    }
    processTag(outputName, attributes) {
        if (attributes["media"]) {
            this.log("warn", `The link for ${attributes["href"]} already has a media attribute, will not modify.`);
        }
        else {
            attributes["media"] = "print";
            attributes["onload"] = attributes["onload"] ? `${attributes["onload"]};` : "";
            attributes["onload"] += "this.media='all'";
            this.log("info", `${outputName}: Modified link to ${attributes["href"]}.`);
        }
    }
}
module.exports = AsyncCssPlugin;
